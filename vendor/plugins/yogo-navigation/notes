Nav:Attribute/DatabaseValue/DisplayValue should have class methods that make everything move nicer

def generate_navigation_display(parameters, level=1)
    table = fetch_table_by_controller(parameters[:controller])
    history = [table]
    if display_conditions(parameters, table)
      display = "<div id='nav_bar'>\n"
      display += "<a href='#' onclick=\"toggle_visibility('#{table + level.to_s}');\">" + 
                 "#{fetch_table_name(table)}</a><br>\n"
      display += "<div id='#{table + level.to_s}' style='display:show'>\n"
      display += "<ul>\n"
        fetch_attributes(table).each do |attribute|
          level += 1
          if attribute.class == Hash
            attribute.each_pair do |relative_table, relationship|
              unless relative_table == table
                history << relative_table
                display += nav_display_prime(relative_table, level, table, history)
                history = [table]
              end
            end
          else
            display += "<a href='#' onclick=\"toggle_visibility" +
                       "('#{table + level.to_s + attribute}');\">" +
                       "#{fetch_attribute_name(table, attribute)}</a><br>\n"
            display += "<div id='#{table + level.to_s + attribute}', style='display:none'>\n"
            display += "<ul>\n"
            fetch_range_display(table, attribute).each do |range|
              display += "<li>#{fetch_path(table, attribute, range)}</li>\n"
            end
            display += "</ul>\n"
            display += "</div>\n"
          end
        end
       display += "</ul>\n"
       display += "</div>\n"
       display += "</div>\n"
    end
    display
  end
  
  # This method is very similar to nav_display, but is not concerned with controllers, and also
  # determines when to stop drilling down through tables.
  def nav_display_prime(table, level, current, history)
    display = "<a href='#' onclick=\"toggle_visibility" + 
              "('#{table + level.to_s + current}');\">#{fetch_table_name(table)}" + # fetch table name used to be pluralized
              "</a><br>\n"
    display += "<div id='#{table + level.to_s + current}', style='display:none'>\n"
    display += "<ul>\n"
    fetch_attributes(table).each do |attribute|
      level += 1
      if attribute.class == Hash
        attribute.each_pair do |relative_table, relationship|
          # Recursion is terminated here.
          unless relative_table == current || relative_table == table
            history << relative_table
            display += nav_display_prime(relative_table, level, table, history)
          end
        end 
      else
        display += "<a href='#' onclick=\"toggle_visibility" +
                   "('#{table + level.to_s + attribute}');\">" + 
                   "#{fetch_attribute_name(table, attribute)}</a><br>\n"
        display += "<div id='#{table + level.to_s + attribute}', style='display:none'>\n"
        display += "<ul>\n"
        fetch_range_display(table, attribute).each do |range|
          display += "<li>#{fetch_path_prime(table, attribute, range, history)}</li>\n"
        end
        display += "</ul>\n"
        display += "</div>\n"
      end
    end
    display += "</ul>\n"
    display += "</div>\n"
    display
  end






  def fetch_path_prime(table, attribute, range, history=nil)
    controller = NavModel.first(:name => history[0]).controller
    database_value = fetch_db_value(table, attribute, range)
    if params[table.to_sym] == nil
       return link_to("#{range}", "#{controller}?#{request.url.split("?")[1]}&#{"TuNNeL-" + history.join("^")}[#{attribute}]=#{database_value}") #+ fetch_count(table, attribute, database_value)
    else
      if params[table.to_sym][attribute] == database_value
        return range
      else
        navlink = "#{controller}?#{request.url.split("?")[1]}&#{table}[#{attribute}]=#{range}"
        navlink.gsub!(Regexp.new("#{table}\\[#{attribute}\\]=.*"), "#{table}[#{attribute}]=#{database_value}")
        return link_to("#{range}", navlink) + fetch_count(table, attribute, database_value)
      end
    end
  end



  def fetch_count(table, attribute, value)
    min, max = parse_value_range(value)
    if NavModel.first(:name => table).nav_attributes.first(:name => attribute).display_count == false
      return ""
    elsif params[table.to_sym].nil?
      if NavModel.first(:name => table).nav_attributes.first(:name => attribute).range == true
        #table.capitalize
        return ' (' + table.constantize.all({attribute => Range.new(min.to_i, max.to_i)}).length.to_s + ')'
      else
        return ' (' + table.constantize.all({attribute => value}).length.to_s + ')'
      end
    else
      if !params[table.to_sym][attribute].nil?
        return ""
      end
      conditions = {}
      conditions.replace(params[table.to_sym])
      if NavModel.first(:name => table).nav_attributes.first(:name => attribute).range == true
        return ' (' + table.capitalize.constantize.all(conditions.update({attribute => Range.new(min.to_i, max.to_i)})).length.to_s + ')'
      else
        return ' (' + table.capitalize.constantize.all(conditions.update({attribute => value})).length.to_s + ')'
      end
    end
  end